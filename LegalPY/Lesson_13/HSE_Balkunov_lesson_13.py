'''
Напишите скрипт, который будет производить сбор данных с выбранной страницы на сайте ЦБ РФ, либо осуществлять загрузку xsl, xslx, pdf, csv или иного файла с данными в рабочую директорию с последующим его парсингом.

У класса должен быть только один публичный метод start(). Все остальные методы, содержащие логику по выгрузке и сохранению данных, должны быть приватными.

Определите структуру для хранения. Например, для ключевой ставки ЦБ РФ это может быть словарь (dict), где ключом будет выступать дата, а значением — размер ключевой ставки на указанную дату.

Оберните весь написанный код парсера в класс ParserCBRF

'''


import json #чтобы сохранить наши данные в формате json
import requests #чтобы пойти по адресу URL в сети и скачать файл
import openpyxl #чтобы прочитать файл .xlsx в питоне
import os #чтобы создать директорию, куда будут складываться файлы и ВАЖНО обеспечить кроссплатформенную запись


# исходный файл содержит месяца словами, а нам нужно будет перевести месяца в цифры. Особенно это важно при работе с datetime,
# т.к. datetime не работает с русским языком, поэтому цифры удобнее.
# Поэтому создаем свой словарь - мэппинг месяцев словами на  месяца в цифрах
MONTHS_DICT = {
    'январь': 1,
    'февраль': 2,
    'март': 3,
    'апрель': 4,
    'май': 5,
    'июнь': 6,
    'июль': 7,
    'август': 8,
    'сентябрь': 9,
    'октябрь': 10,
    'ноябрь': 11,
    'декабрь': 12
}
class ParserCBRF:
    """
    Создаем класс парсера для загрузки данных о краткосрочных кредитах
    для нефинансовых организаций с сайта ЦБ РФ
    """

    def __get_loan_rate_table(self):
        '''сначала нужно создать директорию, куда мы будем сохранять файл
        потом скачать файл по URl адресу с сайта ЦБ РФ
        затем нужно этот скачанный файл записать в формате.xlsx
        URL для парсинга мы нашли вручную на сайте ЦБ РФ
        pars_data - это директория, куда мы будем сохранять файлы
        '''
        if not os.path.exists('pars_data'):
            os.mkdir('pars_data')
        r = requests.get('https://www.cbr.ru/vfs/statistics/pdko/int_rat/loans_nonfin.xlsx')
        with open(os.path.join('pars_data', 'loan_rate_data.xlsx'), 'wb') as f:
            f.write(r.content)

    def __parse_xlsx_file(self):
        '''
        Считывает файл 'loan_rate_data.xlsx' с диска из директории 'pars_data'
        открывает активную страницу wookbook.active
        глазами посмтрели в каких столбцах находятся какие данные:
        столбец А - данные по дате
        столбец Е - данные по ставке
        первые 5 рядов были заняты какими-то зголовками таблицы,
        а последний ряд  [-1] какая-то подпись
        поэтому делаем слайс с 5 ряда до предпоследнего
        через метод zip мы склеиваем даты и ставки из файла 'loan_rate_data.xlsx'
        с помощью функции dict мы создаем словарь
        :return: возвращает словарь, где ключи - даты, а значения - ставка по кредиту
        '''
        wookbook = openpyxl.load_workbook(os.path.join('pars_data', 'loan_rate_data.xlsx'))
        worksheet = wookbook.active
        date_data = [cell.value for cell in worksheet['A'][5:-1]]
        rate_data = [cell.value for cell in worksheet['E'][5:-1]]
        return dict(zip(date_data, rate_data))
# нужно еще сохранить этот файл со словарем
    def start(self):
        '''
        Это главная функция, которая вызывает все остальные шаги парсинга
        сначала вызывает функцию скачивания документа - get_loan_rate_table
        затем вызывает функцию считывания и парсинга файла - parse_xlsx_file
        создаем словарь pairs_dict из строки кода путем вызова функции def parse_xlsx_file(self),
        где эта фенкцию возвращает нам сюда  dict(zip(date_data, rate_data))
        создаем новый пустой словарь CBRF_rate_dict
        теперь проходим по словарю функцией items и достаем оттуда парами ключи и значения
        функцией split разделяем каждую дату ПО ПРОБЕЛУ на месяц и на год - month, year = date.split
        теперь преобразуем отделенный месяц словами в цифру с помощью нашего словаря MONTHS_DICT,
        при этом в нашем словаре  указаны месяцами маленькими буквами,
        а в считанном с сайта ЦБ РФ файле месяца указаны большими буквами,
        поэтому мы переводим месяца в маленькие буквы функцией month.lower
        Теперь в новом словаре CBRF_rate_dict мы складываем пары ключ:значение
        ключ - месяц цифрой, потом дефис год
        значение - строковый вид (str) ставки по кредиту rate
        Теперь открываем файл на запись функцией open, указывая путь к нему
        соединяем две части пути к файлу os.path.join: директория 'pars_data' и название файла 'CBRF_rate_dict.json'
       'w' - аргумент, означающий, что файл открывается на запись
       as f - где f - это указание на открытый для записи файл
       теперь в файл f мы записываем методом dump в формате json наш словарь CBRF_rate_dict
       indent=4 для читаемости, означает, что каждый элемент словаря будет начинаться с 4 пробелов (отступ от левого края)

        '''
        self.__get_loan_rate_table()
        pairs_dict = self.__parse_xlsx_file()
        CBRF_rate_dict = {}
        for date, rate in pairs_dict.items():
            month, year = date.split()
            month_integer = MONTHS_DICT[month.lower()]
            CBRF_rate_dict[f'{month_integer}-{year}'] = str(rate)
        with open(os.path.join('pars_data', 'CBRF_rate_dict.json'), 'w') as f:
            json.dump(CBRF_rate_dict, f, indent=4)



parser = ParserCBRF()
parser.start()


'''
P.S. Вот этой функцией print(help(os.path.exists)) можно вызывать docstring,т.е. строку для документации функции
'''
